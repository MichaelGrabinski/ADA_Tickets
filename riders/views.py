# riders/views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.http import HttpResponse
from django.db.models import Q, Sum, Count
from datetime import date, timedelta

from .models import AdaRiderQ, AdaTicketPurchasesT, TicketAudit  # use your existing tables
from .forms import RiderSearchForm  # keep using the simple search form

def home(request):
    form = RiderSearchForm(initial={'by': 'name'})
    return render(request, 'home.html', {'form': form})

def search_riders(request):
    form = RiderSearchForm(request.GET or None)
    riders = []
    if form.is_valid():
        by = form.cleaned_data['by']
        if by == 'name':
            first = (form.cleaned_data.get('first_name') or '').strip()
            last  = (form.cleaned_data.get('last_name') or '').strip()
            q = Q()
            if first:
                q &= Q(fname__icontains=first)
            if last:
                q &= Q(lname__icontains=last)
            riders = AdaRiderQ.objects.filter(q).order_by('lname', 'fname')[:200]
        else:
            ada_id = (form.cleaned_data.get('ada_id') or '').strip()
            riders = AdaRiderQ.objects.filter(adaid__icontains=ada_id).order_by('lname', 'fname')[:200]
    return render(request, 'search_results.html', {'form': form, 'riders': riders})

def rider_detail(request, pk):
    # pk is NEW_ID in AdaRiderQ
    rider = get_object_or_404(AdaRiderQ, pk=pk)

    # We don't have a strict FK to purchases. Commonly we’ll link by known fields:
    # If your purchases table also has adaid, prefer that. If not, match fname/lname.
    # Try adaid first if present:
    ticket_q = Q()
    if rider.adaid:
        ticket_q = Q(fname=rider.fname, lname=rider.lname) | Q(NEW_ID=rider.NEW_ID)
    else:
        ticket_q = Q(fname=rider.fname, lname=rider.lname)

    tickets = AdaTicketPurchasesT.objects.filter(ticket_q).order_by('-purdate')[:50]
    total_amount = AdaTicketPurchasesT.objects.filter(ticket_q).aggregate(total=Sum('puramt'))['total'] or 0
    total_qty = AdaTicketPurchasesT.objects.filter(ticket_q).aggregate(total=Sum('bkqty'))['total'] or 0

    # Render a detail page using fields that exist in your DB
    return render(request, 'rider_detail.html', {
        'rider': rider,
        'tickets': tickets,
        'total': total_amount,
        'total_qty': total_qty,
    })

def rider_create(request):
    # Creating new rows in an unmanaged table is possible, but you may not need it yet.
    # For now, show a simple form to capture the common fields and insert a row with NEW_ID autogenerated strategy if you have one.
    # If NEW_ID is NOT identity/auto, you’ll need to handle key generation or switch to a staging table.
    return render(request, 'rider_edit.html', {'form': None})

def rider_save(request, pk):
    # Stub, since unmanaged tables and existing keys might be read-only for now.
    return redirect('rider_detail', pk=pk)

def rider_inactive(request, pk):
    rider = get_object_or_404(AdaRiderQ, pk=pk)
    # If updates are allowed:
    rider.Inactive = True
    rider.save(update_fields=['Inactive'])
    return redirect('rider_detail', pk=pk)

from datetime import date, datetime, timedelta
from django.db.models import Sum
from django.db.models.functions import Coalesce
from django.db.models import Value
from django.db.models.functions import TruncDate
from django.utils.dateparse import parse_date
from django.conf import settings

from .models import AdaTicketPurchasesT, TicketAudit

def finance_transmittal(request):
    # read ?start=YYYY-MM-DD&end=YYYY-MM-DD (inclusive)
    start_str = request.GET.get('start')
    end_str = request.GET.get('end')

    today = date.today()
    default_start = today - timedelta(days=30)

    start = parse_date(start_str) if start_str else default_start
    end = parse_date(end_str) if end_str else today

    # ensure sane order; make end inclusive
    if start and end and start > end:
        start, end = end, start

    qs = AdaTicketPurchasesT.objects.all()
    if start:
        qs = qs.filter(purdate__date__gte=start)
    if end:
        qs = qs.filter(purdate__date__lte=end)

    # Build per-day rollups (kept for totals if needed)
    rows = (
        qs.annotate(day=TruncDate('purdate'))
          .values('day')
          .annotate(total_amount=Sum('puramt'), total_qty=Sum('bkqty'))
          .order_by('day')
    )

    # Build per-purchase entries for the transmittal grid
    purchases = list(qs.order_by('purdate').values('TransID', 'purdate', 'bkqty', 'puramt', 'paytype', 'chknum', 'fname', 'lname'))

    # Map audits by trans_id to help get ADA ID via rider_new_id
    trans_ids = [p['TransID'] for p in purchases if p['TransID'] is not None]
    audit_by_trans = {}
    if trans_ids:
        audit_qs = TicketAudit.objects.filter(trans_id__in=trans_ids).order_by('-created_at')
        # last write wins; order ensures latest audit used
        for a in audit_qs:
            if a.trans_id not in audit_by_trans:
                audit_by_trans[a.trans_id] = a

    # Build rider_new_id -> adaid map
    rider_ids = [a.rider_new_id for a in audit_by_trans.values() if a.rider_new_id]
    adaid_map = {}
    if rider_ids:
        for rid, adaid in AdaRiderQ.objects.filter(NEW_ID__in=rider_ids).values_list('NEW_ID', 'adaid'):
            adaid_map[rid] = adaid

    entry_rows = []
    for p in purchases:
        a = audit_by_trans.get(p['TransID'])
        ada_id = None
        if a and a.rider_new_id:
            ada_id = adaid_map.get(a.rider_new_id)
        if not ada_id:
            ada_id = AdaRiderQ.objects.filter(fname=p['fname'], lname=p['lname']).values_list('adaid', flat=True).first()
        entry_rows.append({
            'paytype': p['paytype'],
            'purchase_date': p['purdate'],
            'adaid': ada_id,
            'name': f"{(p['lname'] or '').strip()}, {(p['fname'] or '').strip()}",
            'qty': p['bkqty'] or 0,
            'amount': p['puramt'] or 0,
            'chknum': p['chknum'] or '',
        })

    # Grand totals across the filtered queryset
    grand = qs.aggregate(grand_total_amount=Sum('puramt'), grand_total_qty=Sum('bkqty'))
    grand_total_amount = grand.get('grand_total_amount') or 0
    grand_total_qty = grand.get('grand_total_qty') or 0

    # Optional: PDF export of the current view
    if request.GET.get('format') == 'pdf':
        try:
            from django.template.loader import get_template
            from xhtml2pdf import pisa

            # Prefer the riders static seal image, fallback to permits banner
            logo_uri = None
            riders_logo = settings.BASE_DIR / 'riders' / 'static' / 'tc-eh-town-seal.jpeg'
            permits_logo = settings.BASE_DIR / 'permits' / 'static' / 'town_banner.png'
            if riders_logo.exists():
                logo_uri = f"file:///{riders_logo.as_posix()}"
            elif permits_logo.exists():
                logo_uri = f"file:///{permits_logo.as_posix()}"

            template = get_template('finance_transmittal_pdf.html')
            html = template.render({
                'entries': entry_rows,
                'start': start,
                'end': end,
                'grand_total_amount': grand_total_amount,
                'grand_total_qty': grand_total_qty,
                'logo_uri': logo_uri,
            })
            response = HttpResponse(content_type='application/pdf')
            response['Content-Disposition'] = 'attachment; filename="finance-transmittal.pdf"'
            pisa.CreatePDF(src=html, dest=response)
            return response
        except Exception as e:
            return HttpResponse(f"PDF generation failed: {e}", status=500)

    return render(request, 'finance_transmittal.html', {
    'rows': rows,
    'entries': entry_rows,
        'start': start,
        'end': end,
        'grand_total_amount': grand_total_amount,
        'grand_total_qty': grand_total_qty,
    })


from django.shortcuts import render, redirect, get_object_or_404
from django.utils import timezone
from .models import AdaRiderQ, AdaTicketPurchasesT, TicketAudit
from .forms import TicketForm

def ticket_create(request, pk):
    rider = get_object_or_404(AdaRiderQ, pk=pk)

    if request.method == 'POST':
        form = TicketForm(request.POST)
        if form.is_valid():
            t = form.save(commit=False)

            # Link the ticket to this rider.
            # If your ticket table actually has `adaid`, prefer:  t.adaid = rider.adaid
            t.fname = rider.fname
            t.lname = rider.lname

            # Reasonable defaults (optional)

# views.py
from decimal import Decimal
from django.shortcuts import render, redirect, get_object_or_404
from django.utils import timezone
from .models import AdaRiderQ, AdaTicketPurchasesT, TicketAudit
from .forms import TicketForm

# views.py
from decimal import Decimal
from django.db import transaction
from django.db.models import Max
from django.shortcuts import render, redirect, get_object_or_404
from django.utils import timezone
from .models import AdaRiderQ, AdaTicketPurchasesT
from .forms import TicketForm

UNIT_PRICE = Decimal('28.00')

def ticket_create(request, pk):
    rider = get_object_or_404(AdaRiderQ, pk=pk)

    if request.method == 'POST':
        form = TicketForm(request.POST)
        if form.is_valid():
            t = form.save(commit=False)

            # link to rider
            t.fname = rider.fname
            t.lname = rider.lname
            if not t.purdate:
                t.purdate = timezone.now()

            # compute amount from qty
            qty = t.bkqty or 0
            t.puramt = (Decimal(qty) * UNIT_PRICE).quantize(Decimal('0.01'))

            # ---- HOTFIX: generate TransID ourselves
            with transaction.atomic():
                next_id = (AdaTicketPurchasesT.objects.aggregate(m=Max('TransID'))['m'] or 0) + 1
                t.TransID = next_id
                t.save()

                # Create audit/receipt row
                TicketAudit.objects.create(
                    trans_id=t.TransID,
                    rider_new_id=rider.NEW_ID,
                    fname=t.fname,
                    lname=t.lname,
                    created_by=(request.user.get_username() if request.user.is_authenticated else 'anonymous'),
                    deptenter=t.deptenter,
                    paytype=t.paytype,
                    chknum=t.chknum,
                    amount=t.puramt or 0,
                    qty=t.bkqty or 0,
                    notes=getattr(t, 'Notes', None),
                )
            return redirect('receipt_view', trans_id=t.TransID)
    else:
        initial = {'purdate': timezone.now().replace(microsecond=0), 'bkqty': 1}
        form = TicketForm(initial=initial)

    return render(request, 'ticket_form.html', {'form': form, 'rider': rider})


def receipt_view(request, trans_id: int):
    # Load from primary table and audit
    purchase = get_object_or_404(AdaTicketPurchasesT, TransID=trans_id)
    audit = TicketAudit.objects.filter(trans_id=trans_id).order_by('-created_at').first()
    rider = AdaRiderQ.objects.filter(fname=purchase.fname, lname=purchase.lname).first()
    context = {'purchase': purchase, 'audit': audit, 'rider': rider}

    # Support PDF download
    if request.GET.get('format') == 'pdf':
        try:
            from django.template.loader import get_template
            from xhtml2pdf import pisa
            template = get_template('receipt_pdf.html')
            html = template.render(context)
            response = HttpResponse(content_type='application/pdf')
            response['Content-Disposition'] = f'attachment; filename="receipt-{trans_id}.pdf"'
            pisa.CreatePDF(src=html, dest=response)
            return response
        except Exception as e:
            return HttpResponse(f"PDF generation failed: {e}", status=500)

    return render(request, 'receipt.html', context)


def finance_detail_report(request):
    # Params: ?start=YYYY-MM-DD&end=YYYY-MM-DD&user=username(optional)
    start_str = request.GET.get('start')
    end_str = request.GET.get('end')

    # Default to past 30 days if no dates provided
    start = parse_date(start_str) if start_str else None
    end = parse_date(end_str) if end_str else None
    if not start and not end:
        today = date.today()
        start = today - timedelta(days=30)
        end = today
    if start and end and start > end:
        start, end = end, start

    # Filter audits by purchase date range by joining via TransID to purchases
    qs = TicketAudit.objects.all()
    purchases_for_range = AdaTicketPurchasesT.objects.all()
    if start:
        purchases_for_range = purchases_for_range.filter(purdate__date__gte=start)
    if end:
        purchases_for_range = purchases_for_range.filter(purdate__date__lte=end)
    # Restrict audits to those whose TransID appears in purchases within range
    purchase_ids_qs = purchases_for_range.exclude(TransID__isnull=True).values_list('TransID', flat=True)
    qs = qs.filter(trans_id__in=purchase_ids_qs)

    # Build per-entry audit list annotated with purchase date and ADA ID (for display)
    purchase_dates = dict(
        purchases_for_range.exclude(TransID__isnull=True)
            .values_list('TransID', 'purdate')
    )
    # Map rider_new_id -> ADA ID for quick lookup
    rider_ids = list(qs.exclude(rider_new_id=None).values_list('rider_new_id', flat=True).distinct())
    adaid_map = {}
    if rider_ids:
        for rid, adaid in AdaRiderQ.objects.filter(NEW_ID__in=rider_ids).values_list('NEW_ID', 'adaid'):
            adaid_map[rid] = adaid
    audit_entries = [
        {
            'trans_id': a.trans_id,
            'created_by': a.created_by,
            'deptenter': a.deptenter,
            'qty': a.qty,
            'amount': a.amount,
            'created_at': a.created_at,
            'purchase_date': purchase_dates.get(a.trans_id),
            'adaid': adaid_map.get(a.rider_new_id) or (AdaRiderQ.objects.filter(fname=a.fname, lname=a.lname).values_list('adaid', flat=True).first()),
        }
        for a in qs.order_by('-created_at')
    ]

    # Build per-purchase entry rows with ADA ID and User (created_by)
    audits_by_trans = {a.trans_id: a for a in qs}
    entry_rows = []
    for p in purchases_for_range.order_by('-purdate'):
        a = audits_by_trans.get(p.TransID)
        created_by = a.created_by if a else (p.deptenter or 'legacy-import')
        # Prefer ADA ID via audit->rider_new_id, else fallback by name
        ada_id = (adaid_map.get(a.rider_new_id) if a and a.rider_new_id else None)
        if not ada_id:
            ada_id = AdaRiderQ.objects.filter(fname=p.fname, lname=p.lname).values_list('adaid', flat=True).first()
        entry_rows.append({
            'trans_id': p.TransID,
            'adaid': ada_id,
            'rider_name': f"{(p.lname or '').strip()}, {(p.fname or '').strip()}",
            'user': created_by,
            'dept': p.deptenter,
            'qty': p.bkqty or 0,
            'amount': p.puramt or 0,
            'purchase_date': p.purdate,
        })

    # Diagnostics removed; we only need entry rows now

    return render(request, 'finance_detail.html', {
        'entry_rows': entry_rows,
        'start': start,
        'end': end,
    })

